"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bindings_1 = __importDefault(require("bindings"));
const stream_1 = require("stream");
const porcupine = bindings_1.default("pv_porcupine.node");
exports.default = porcupine;
class PorcupineStream extends stream_1.Writable {
    constructor(options) {
        super(options);
        this.bufferLength = 0;
        this.porcupine = new porcupine.Porcupine(options.moduleFilePath, options.keywords);
        this.frameSize = porcupine.frameLength() * 2;
        this.buffer = Buffer.allocUnsafe(this.frameSize);
    }
    _write(chunk, encoding, callback) {
        if (typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
        }
        if (!(chunk instanceof Buffer)) {
            callback(new Error("PorcupineStream does not support object mode."));
            return;
        }
        const frameSize = this.frameSize;
        let offset = 0;
        if (this.bufferLength > 0) {
            const bytesToCopy = Math.min(frameSize - this.bufferLength, chunk.length);
            chunk.copy(this.buffer, this.bufferLength, 0, bytesToCopy);
            this.bufferLength += bytesToCopy;
            offset = bytesToCopy;
            if (this.bufferLength === frameSize) {
                const result = this.porcupine.process(this.buffer);
                this.bufferLength = 0;
                if (result !== false && result !== -1) {
                    this.emit("keyword", chunk.slice(offset), result === true ? 0 : result);
                    callback();
                    return;
                }
            }
        }
        while (offset + frameSize <= chunk.length) {
            const result = this.porcupine.process(chunk.slice(offset, offset + frameSize));
            offset += frameSize;
            if (result !== false && result !== -1) {
                this.emit("keyword", chunk.slice(offset), result === true ? 0 : result);
                callback();
                return;
            }
        }
        if (offset < chunk.length) {
            chunk.copy(this.buffer, 0, offset);
            this.bufferLength = chunk.length - offset;
        }
        callback();
    }
    _destroy(err, callback) {
        this.porcupine.destroy();
        callback(err || undefined);
    }
}
exports.PorcupineStream = PorcupineStream;
